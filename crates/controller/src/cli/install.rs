//! Installation command for Secret Manager Controller
//!
//! Embeds Kubernetes manifests at compile time and applies them to the cluster.
//! Similar to `flux install`, this command installs the controller CRDs, RBAC, and deployment.
//!
//! Uses kubectl apply via subprocess for reliable manifest application, similar to FluxCD's approach.

use anyhow::{Context, Result};
use controller::crd::SecretManagerConfig;
use kube::{Client, core::CustomResourceExt};
use std::io::Write;
use std::process::Command;
use tempfile::NamedTempFile;

/// Embedded manifests - embedded at compile time from config/ directory
///
/// These manifests are read from disk at COMPILE TIME using include_str! macro.
/// This means:
/// - The manifests are baked into the binary when it's built
/// - Changes to config/*.yaml files after building won't affect the binary
/// - This is the same approach FluxCD uses (Go's embed directive)
///
/// Note: CRD is NOT included here - it's generated dynamically from Rust code
/// at runtime using SecretManagerConfig::crd() to avoid stale CRD files.
///
/// Static manifests (RBAC, Deployment, Service) are fine to embed because:
/// - They don't change based on code changes
/// - They're versioned with the binary
/// - They're idempotent (kubectl apply handles updates)
mod manifests {
    // Include namespace
    const NAMESPACE: &str = include_str!("../../../../config/namespace.yaml");

    // Include RBAC resources
    const SERVICE_ACCOUNT: &str = include_str!("../../../../config/rbac/serviceaccount.yaml");
    const ROLE: &str = include_str!("../../../../config/rbac/role.yaml");
    const ROLEBINDING: &str = include_str!("../../../../config/rbac/rolebinding.yaml");
    const CLUSTER_ROLE: &str = include_str!("../../../../config/rbac/clusterrole.yaml");
    const CLUSTER_ROLE_BINDING: &str =
        include_str!("../../../../config/rbac/clusterrolebinding.yaml");
    // Note: role-sops-secret.yaml and rolebinding-sops-secret.yaml were removed as redundant
    // They duplicated permissions already granted by role.yaml and rolebinding.yaml

    // Include deployment
    const DEPLOYMENT: &str = include_str!("../../../../config/deployment/deployment.yaml");

    // Include service
    const METRICS_SERVICE: &str = include_str!("../../../../config/service/metrics-service.yaml");

    /// Get all embedded manifests (excluding CRD, which is generated dynamically)
    pub fn get_static_manifests() -> Vec<&'static str> {
        vec![
            NAMESPACE,
            SERVICE_ACCOUNT,
            ROLE,
            ROLEBINDING,
            CLUSTER_ROLE,
            CLUSTER_ROLE_BINDING,
            // Note: ROLE_SOPS_SECRET and ROLEBINDING_SOPS_SECRET removed (redundant)
            DEPLOYMENT,
            METRICS_SERVICE,
        ]
    }
}

/// Generate CRD YAML dynamically from Rust code
/// This ensures we always use the latest CRD definition, not a stale file from disk
fn generate_crd_yaml() -> Result<String> {
    // Generate CRD from Rust type definition
    let crd = SecretManagerConfig::crd();

    // Serialize to YAML
    let yaml = serde_yaml::to_string(&crd).context("Failed to serialize CRD to YAML")?;

    // Add header comment
    let mut crd_yaml = String::from("# This CRD is auto-generated from Rust code at runtime\n");
    crd_yaml.push_str("# DO NOT EDIT THIS FILE MANUALLY\n");
    crd_yaml.push_str("# Generated by: msmctl install\n");
    crd_yaml.push_str("#\n");
    crd_yaml.push_str("---\n");
    crd_yaml.push_str(&yaml);

    Ok(crd_yaml)
}

/// Install the Secret Manager Controller to the cluster
pub async fn install_command(
    _client: Client, // Keep for API compatibility, but we use kubectl directly
    namespace: Option<String>,
    export: bool,
    dry_run: bool,
) -> Result<()> {
    let ns = namespace.as_deref().unwrap_or("octopilot-system");

    if export {
        // Export mode: just print manifests to stdout
        println!("{}", get_combined_manifests(ns)?);
        return Ok(());
    }

    if dry_run {
        println!("üîç Dry-run mode: Would install Secret Manager Controller to namespace '{ns}'");
        println!();
        println!("{}", get_combined_manifests(ns)?);
        return Ok(());
    }

    println!("üöÄ Installing Secret Manager Controller...");
    println!("   Namespace: {ns}");
    println!();

    // Generate CRD dynamically from Rust code
    println!("   [1/11] Generating CRD from Rust code...");
    let crd_yaml = generate_crd_yaml().context("Failed to generate CRD from Rust code")?;

    // Parse CRD to get name for logging
    let crd_doc: serde_yaml::Value =
        serde_yaml::from_str(&crd_yaml).context("Failed to parse generated CRD YAML")?;
    let crd_name = crd_doc
        .get("metadata")
        .and_then(|m| m.get("name"))
        .and_then(|n| n.as_str())
        .unwrap_or("SecretManagerConfig CRD");

    println!("   [1/11] Applying CustomResourceDefinition: {}", crd_name);
    apply_manifest(&crd_yaml, ns).with_context(|| format!("Failed to apply CRD: {}", crd_name))?;

    // Apply static manifests
    let static_manifests = manifests::get_static_manifests();

    for (idx, manifest_yaml) in static_manifests.iter().enumerate() {
        // Parse YAML to get kind and name for logging
        let doc: serde_yaml::Value =
            serde_yaml::from_str(manifest_yaml).context("Failed to parse manifest YAML")?;

        let kind = doc
            .get("kind")
            .and_then(|k| k.as_str())
            .unwrap_or("<unknown>");
        let name = doc
            .get("metadata")
            .and_then(|m| m.get("name"))
            .and_then(|n| n.as_str())
            .unwrap_or("<unknown>");

        let manifest_num = idx + 2; // Start from 2 since CRD is 1
        println!("   [{}/11] Applying {}: {}", manifest_num, kind, name);

        // Apply using kubectl apply
        apply_manifest(manifest_yaml, ns)
            .with_context(|| format!("Failed to apply {}: {}", kind, name))?;
    }

    println!();
    println!("‚úÖ Secret Manager Controller installed successfully!");
    println!();
    println!("üìã Next steps:");
    println!("   1. Verify controller is running:");
    println!("      kubectl get pods -n {ns}");
    println!("   2. Create a SecretManagerConfig resource");
    println!("   3. Check controller logs:");
    println!("      kubectl logs -n {ns} -l app=secret-manager-controller");

    Ok(())
}

/// Apply a single manifest to the cluster using kubectl apply
/// This is simpler and more reliable than using kube-rs for all resource types
fn apply_manifest(manifest_yaml: &str, default_namespace: &str) -> Result<()> {
    // Write manifest to temporary file
    let mut temp_file = NamedTempFile::new().context("Failed to create temporary file")?;

    // Replace namespace placeholder if needed
    let manifest_with_ns = manifest_yaml.replace("octopilot-system", default_namespace);
    temp_file
        .write_all(manifest_with_ns.as_bytes())
        .context("Failed to write manifest to temporary file")?;

    let temp_path = temp_file.path();

    // Use kubectl apply
    let path_str = temp_path.to_str().ok_or_else(|| {
        anyhow::anyhow!(
            "Temporary file path contains invalid UTF-8: {:?}",
            temp_path
        )
    })?;
    let output = Command::new("kubectl")
        .args(&["apply", "-f", path_str])
        .output()
        .context("Failed to execute kubectl apply. Ensure kubectl is installed and in PATH.")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(anyhow::anyhow!("kubectl apply failed: {}", stderr));
    }

    Ok(())
}

/// Get combined manifests as a single YAML string (for export/dry-run)
fn get_combined_manifests(namespace: &str) -> Result<String> {
    let mut combined = String::new();

    // Generate CRD dynamically
    let crd_yaml = generate_crd_yaml()?;
    combined.push_str(&crd_yaml);
    combined.push_str("\n---\n");

    // Add static manifests
    let static_manifests = manifests::get_static_manifests();
    for manifest in static_manifests {
        // Replace namespace placeholder if present
        let manifest_with_ns = manifest.replace("octopilot-system", namespace);
        combined.push_str(&manifest_with_ns);
        combined.push_str("\n---\n");
    }

    Ok(combined)
}
